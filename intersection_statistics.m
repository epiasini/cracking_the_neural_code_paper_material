function [I_stim, I_choice, II, fII, alpha, beta] = intersection_statistics(...
        faithful_idx_1, left_idx_1,...
        faithful_idx_2, left_idx_2, shuffle)
    % Compute some statistics related to intersection information. This
    % function is only meant as a helper to 'intersection_rasters'.
    
    
    % all variables are those generated by
    % generate_faithful_and_misleading_data, except 'shuffle' that controls
    % whether to destroy conditional dependence between choice and decoded
    % stimulus given the stimulus (i.e. whether to set
    % p(s_hat,c|s)=p(s_hat|s)p(c|s) in the data.

    n_trials_1 = numel(faithful_idx_1);
    n_trials_2 = numel(faithful_idx_2);
    n_trials = n_trials_1 + n_trials_2;
    
    if shuffle
        [faithful_idx_1, left_idx_1] = shuffle_conditions(faithful_idx_1, left_idx_1);
        [faithful_idx_2, left_idx_2] = shuffle_conditions(faithful_idx_2, left_idx_2);
    end
    
    trial_conditions_1 = faithfulness_and_correctness(faithful_idx_1, left_idx_1, 1);
    trial_conditions_2 = faithfulness_and_correctness(faithful_idx_2, left_idx_2, 0);
    trial_conditions = [trial_conditions_1, trial_conditions_2];
    
    alpha_1 = get_alpha(trial_conditions_1);
    alpha_2 = get_alpha(trial_conditions_2);
    beta_1 = get_beta(trial_conditions_1);
    beta_2 = get_beta(trial_conditions_2);
    
    alpha = mean([alpha_1, alpha_2]);
    beta = mean([beta_1, beta_2]);
    
    I_stim = alpha;
    I_choice = (nnz(trial_conditions==1) + nnz(trial_conditions==3))/n_trials;
    II = alpha * beta;
    fII = beta;   
    
end

function [shuffled_faithful, shuffled_left] = shuffle_conditions(faithful_idx, left_idx)
    n_trials = numel(faithful_idx);
    shuffled_faithful = false(1, n_trials);
    shuffled_left = false(1, n_trials);
    shuffled_faithful(randsample(n_trials, nnz(faithful_idx))) = true;
    shuffled_left(randsample(n_trials, nnz(left_idx))) = true;
end


function conditions = faithfulness_and_correctness(faithful_idxs, choice_idxs, correct_choice)
    % 'choice_idxs' must be true (1) for left, false (0) for
    % right. The same convention is used to specify which
    % choice is correct in 'correct_choice': 1 for left, 0 for
    % right. The 'conditions' are defined as following:
    % 1 - faithful and correct
    % 2 - faithful and error
    % 3 - misleading and correct
    % 4 - misleading and error
    n_trials = numel(choice_idxs);
    faithful_and_correct = (choice_idxs==correct_choice) & faithful_idxs;
    faithful_and_error = (choice_idxs~=correct_choice) & faithful_idxs;
    misleading_and_correct = (choice_idxs==correct_choice) & ~faithful_idxs;
    misleading_and_error = (choice_idxs~=correct_choice) & ~faithful_idxs;
    
    conditions = zeros(1,n_trials);
    conditions(faithful_and_correct) = 1;
    conditions(faithful_and_error) = 2;
    conditions(misleading_and_correct) = 3;
    conditions(misleading_and_error) = 4;
end

function a = get_alpha(conditions)
    % alpha is the fraction of faithful trials wrt the total
    n_trials = numel(conditions);
    a = (nnz(conditions==1) + nnz(conditions==2))/n_trials;
end

function b = get_beta(conditions)
    % beta is the fraction of faithful trials that are correct
    b = nnz(conditions==1)/(nnz(conditions==1)+nnz(conditions==2));
end